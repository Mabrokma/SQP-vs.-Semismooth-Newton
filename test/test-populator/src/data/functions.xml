<functions>

	<function>
		<name>quad_func</name>
		<var>x</var>
		<constant>
			<constant_name>xd</constant_name>
			<constant_value>3</constant_value>
		</constant>
		<def>y = norm(x-xd)^2;</def>
		<grad>g = 2*(x-xd);</grad>
		<hess>H = 2*eye(length(x));</hess>
	</function>

	<function>
		<name>linear_func</name>
		<var>x</var>
		<constant>
			<constant_name>c</constant_name>
			<constant_value>[1;1]</constant_value>
		</constant>
		<def>y = c'*x;</def>
		<grad>g = c;</grad>
		<hess>H = zeros(length(c));</hess>
	</function>
	
	<function>
		<name>exp_func</name>
		<var>x</var>
		<def>y = exp(norm(x)^2);</def>
		<grad>g = 2*exp_func(x)*x;</grad>
		<hess>
	n = length(x);
	efx = exp(norm(x)^2);
	H = 2*efx*eye(n);
	for k=1:n
		for l=1:n
			H(k,l) = H(k,l) + 4*efx*x(k)*x(l);
		end
	end
		</hess>
	</function>

	<function>
		<name>rosenbrock_func</name>
		<var>x</var>
		<def>y = 100*(x(2)-x(1)^2)^2+(1-x(1))^2;</def>
		<grad>g = [-400*x(1)*(x(2)-x(1)^2)-2*(1-x(1)); 200*(x(2)-x(1)^2)];</grad>
		<hess>
	H = [ 1200*x(1)^2-400*x(2)+2  -400*x(1);
              -400*x(1)              200  ];
        </hess>
	</function>

	<function>
		<name>himmelblau_func</name>
		<var>x</var>
		<def>y = (x(1)^2+x(2)-11)^2 + (x(1)+x(2)^2-7)^2;</def>
		<grad>
	g = [ 4*x(1)*(x(1)^2+x(2)-11) + 2*(x(1)+x(2)^2-7);
		  2*(x(1)^2+x(2)-11) + 4*x(2)*(x(1)+x(2)^2-7) ];
		</grad>
		<hess>
	H = [ 12*x(1)^2+4*x(2)-42    4*(x(1)+x(2));
             4*(x(1)+x(2))    4*x(1)+12*x(2)^2-26  ];
        </hess>
	</function>
	
	<function>
		<name>bazaraa_shetty_func</name>
		<var>x</var>
		<def>y = (x(1)-2)^4+(x(1)-2*x(2))^2;</def>
		<grad>
	g = [ 4*(x(1)-2)^3+2*x(1)-4*x(2);
	         -4*x(1)+8*x(2) ];
		</grad>
		<hess>
	H = [ 12*(x(1)-2)^2+2  -4;
               -4           8 ];
        </hess>
	</function>

	<function>
		<name>schuldt_func</name>
		<var>x</var>
		<def>y = x(2)+(1/100000)*(x(2)-x(1)^2)^2;</def>
		<grad>not available</grad>
		<hess>not available</hess>
	</function>

	<function>
		<name>asaadi_func</name>
		<var>x</var>
		<def>y = x(2)+(1/3)*(x(1)+1)^3;</def>
		<grad>not available</grad>
		<hess>not available</hess>
	</function>

	<function>
		<name>mccormick_func</name>
		<var>x</var>
		<def>y = sin(x(1)+x(2)) + (x(1)-x(2))^2 - 1.5*x(1) + 2.5*x(2) + 1;</def>
		<grad>not available</grad>
		<hess>not available</hess>
	</function>

	<!--function>
		<name>holzmann_func</name>
		<var>x</var>
		<def>
	y = 0;
	for k=1:99
		u = 25 + (-50*log(0.01*k))^(2/3);
		y = y + ( -0.1*k + exp( -(1/x(1)) * ( u - x(2) )^x(3) ) )^2;
	end
		</def>
		<grad>not available</grad>
		<hess>not available</hess>
	</function-->

	<function>
		<name>dixon_2_dim_func</name>
		<var>x</var>
		<def>y = (1-x(1))^2+(x(1)^2-x(2))^2+(1-x(2))^2;</def>
		<grad>
	g = [ -2*(1-x(1)) + 4*x(1)*(x(1)^2-x(2));
	         -2*(x(1)^2-x(2)) - 2*(1-x(2)) ];
		</grad>
		<hess>
	H = [ 2+12*x(1)^2-4*x(2)  -4*x(1);
               -4*x(1)           4   ];
        </hess>
	</function>

	<function>
		<name>dixon_3_dim_func</name>
		<var>x</var>
		<def>y = (1-x(1))^2+(x(1)^2-x(2))^2+(x(2)^2-x(3))^2+(1-x(3))^2;</def>
		<grad>
	g = [ -2*(1-x(1)) + 4*x(1)*(x(1)^2-x(2));
          -2*(x(1)^2-x(2)) + 4*x(2)*(x(2)^2-x(3));
	         -2*(x(2)^2-x(3)) - 2*(1-x(3)) ];
		</grad>
		<hess>
	H = [ 2+12*x(1)^2    -4*x(1)       0;
             -4*x(1)   2+12*x(2)^2  -4*x(2);
               0         -4*x(2)       4 ];
        </hess>
	</function>

	<function>
		<name>dixon_func</name>
		<var>x</var>
		<constant>
			<constant_name>n</constant_name>
			<constant_value>10</constant_value>
		</constant>
		<def>
	y = (1-x(1))^2;
	for k=1:(n-1)
		y = y + (x(k)^2-x(k+1))^2;
	end
	y = y + (1-x(n))^2;
		</def>
		<grad>
	g(1,1) = -2*(1-x(1)) + 4*x(1)*(x(1)^2-x(2));
    for k=2:(n-1)
		g(k,1) = -2*(x(k-1)^2-x(k)) + 4*x(k)*(x(k)^2-x(k+1));
	end
	g(n,1) = -2*(x(n-1)^2-x(n)) - 2*(1-x(n));
		</grad>
		<hess>
	for k=1:n
		for l=1:n
			H(k,l) = 0;
			if (l == k-1)
				H(k,l) = -4*x(k-1);
			end
			if (l == k)
				H(k,l) = 2+12*x(k)^2;
			end
			if (l == k+1)
				H(k,l) = -4*x(k);
			end
		end
	end
	H(n,n) = 4;
        </hess>
	</function>

	<function>
		<name>colville_func</name>
		<var>x</var>
		<def>y = 100*(x(2)-x(1)^2)^2 + (1-x(1))^2 + 90*(x(4)-x(3)^2)^2 + (1-x(3))^2 ...
				 + 10.1*((x(2)-1)^2 + (x(4)-1)^2) + 19.8*(x(2)-1)*(x(4)-1);</def>
		<grad>not available</grad>
		<hess>not available</hess>
	</function>

	<function>
		<name>betts_func</name>
		<var>x</var>
		<def>y = 2 - (1/2)*x(1)*x(2);</def>
		<grad>not available</grad>
		<hess>not available</hess>
	</function>
	
	<function>
		<name>paviani_func</name>
		<var>x</var>
		<def>
	y = 0;
	for k=1:2
		y = y - ( (log(x(k)-2))^2 + (log(10-x(k)))^2 );
	end
		</def>
		<grad>not available</grad>
		<hess>not available</hess>
	</function>
	
</functions>